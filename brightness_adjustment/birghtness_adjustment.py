# -*- coding: utf-8 -*-
"""
Created on 2017 Nov 19 

GLIA PULSE OXIMETER AUTOMATIC BRIGHTNESS ADJUSTMENT ALGORITHM ANALYSIS

Copyright (C) 2018 Luka Banovic <banovic@irnas.eu>

This script is based on 04_data_analysis.py for analysis of automatic brightness adjustment algorithm testing.

All projects of Institute IRNAS are as usefully open-source as possible.

Firmware and software originating from the project is licensed under GNU GENERAL PUBLIC LICENSE v3
<http://www.gnu.org/licenses/gpl-3.0.en.html>.

Open data generated by our projects is licensed under CC0 <https://creativecommons.org/publicdomain/zero/1.0/legalcode>.

All our websites and additional documentation are licensed under Creative Commons Attribution-ShareAlike 4 .0 Unported License
<https://creativecommons.org/licenses/by-sa/4.0/legalcode>.

What this means is that you can use hardware, firmware, software and documentation without paying a royalty and knowing that 
you'll be able to use your version forever. You are also free to make changes but if you share these changes then you have to 
do so on the same conditions that you enjoy.

Koruza, GoodEnoughCNC and IRNAS are all names and marks of Institut IRNAS Raƒçe. You may use these names and terms only to 
attribute the appropriate entity as required by the Open Licences referred to above. You may not use them in any other way 
and in particular you may not use them to imply endorsement or authorization of any hardware that you design, make or sell.



"""


import os
os.chdir(r'/home/irnas/Documents/GliaX/pulseoxi/python')
import pandas
import numpy as np
from scipy.signal import butter, filtfilt
import matplotlib.pyplot as plt


def load_dataset_2(filename):
    """
    time,raw_ir,dc_ir,butt_ir,noise_ir,dc_red,butt_red,noise_red, raw_red, ir_bright, red_bright, SQI_ir, SQI_red
    """
    data = pandas.read_csv(filename, header=None, names=['ts', 'raw_ir', 'dc_ir', 'butt_ir', 'noise_ir','dc_red','butt_red','noise_red',
                                                         'raw_red','ir_bright','red_bright', 'SQI_ir', 'SQI_red'])
    time = data['ts']
    time = data['ts'] - data['ts'][0]
    time = time/1000

    raw_ir = data['raw_ir']
    dc_ir = data['dc_ir']/100
    butt_ir = data['butt_ir']/100
    noise_ir = data['noise_ir']/100
    dc_red = data['dc_red']/100
    butt_red = data['butt_red']/100
    noise_red = data['noise_red']/100
    raw_red = data['raw_red']
    ir_bright = data['ir_bright']
    red_bright = data['red_bright']
    sqi_ir = data['SQI_ir']/100
    sqi_red = data['SQI_red']/100
    
    
    return time, raw_ir, dc_ir, butt_ir, noise_ir, dc_red, butt_red, noise_red, raw_red, ir_bright, red_bright, sqi_ir, sqi_red

        
   #%%     
def butter_lowpass(cut, fs, order=2):
    nyq = 0.5 * fs
    cut = cut / nyq
    b, a = butter(order, [cut], btype='low')
    return b, a

def butter_lowpass_filter(data, cut, fs, order=2):
    b, a = butter_lowpass(cut, fs, order=order)
    y = filtfilt(b, a, data)
    return y

def butter_highpass(cut, fs, order=2):
    nyq = 0.5 * fs
    cut = cut / nyq
    b, a = butter(order, [cut], btype='high')
    return b, a

def butter_highpass_filter(data, cut, fs, order=2):
    b, a = butter_highpass(cut, fs, order=order)
    y = filtfilt(b, a, data)
    return y


class PeakDetector(object):
    def __init__(self, threshold):
        self.threshold = threshold
        self.previous_value = None
        self.state = 'idle'

    def push(self, value):
        if self.state == 'idle':
            if value <= self.threshold:
                self.state = 'rising'
        
        elif self.state == 'rising':
            if value < self.previous_value:
                pass
            else:
                self.state = 'falling'
                return True
        elif self.state == 'falling':
            if value > self.threshold:
                self.state = 'idle'

        self.previous_value = value
        return False    


def trough_decection(signal, treshold):
    """
    """
    detector = PeakDetector(threshold=treshold)
    peaks = [detector.push(x) for x in signal]
    peaks = np.asarray(peaks)
    
    item = True
    peaks = np.where(peaks == item)
    peaks = peaks[0]
    return peaks


#%%

"""======================================================================="""   
filename = 'capture.txt'
time, raw_ir, dc_ir, butt_ir, noise_ir, dc_red, butt_red, noise_red, raw_red, ir_bright, red_bright, sqi_ir, sqi_red = load_dataset_2(filename)
peaks = trough_decection(butt_ir, treshold=0)

plt.figure(1)
plt.subplot(3,1,1)
plt.plot(time, raw_ir)
plt.subplot(3,1,2)
plt.plot(time, sqi_ir)
plt.subplot(3,1,3)
plt.plot(time, ir_bright)

